package launchers;

import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import utilities.CandidateData;
import utilities.ElectionData;
import utilities.InFile;
import utilities.OutFile;

//TODO deal with quoted commas in some of the lines
public class fileScraperAL
{
	public static void main(String args[]) throws IOException
	{
		String state = "AL"; //TODO set up arrays for county, precinct
		String type = "precinct";
		String party = "null"; //TODO the AL files do not have parties; need to see if there's another list somewhere
		
		String path = "C:\\Users\\Robbie\\Documents\\dissertation\\Data"
				+ "\\elections\\stateResults\\" + state;
		String fileType = ".txt";
		
		String[] folders = new File(path).list(new FilenameFilter()
		{
			public boolean accept(File current, String name)
			{
				return new File(current, name).isDirectory();
			}
		});
		
		OutFile log = null;
		try
		{
			log = new OutFile(path + "\\debugLog.txt", false);
		}
		catch (IOException e)
		{
			System.err.println("Error in setting up output file " + path + ".txt");
			e.printStackTrace();
		}
		
		for (String folder : folders)
		{
			int year = Integer.parseInt(folder);
			log.writeLine("***" + year);
			
			File[] inputFiles = new File(path + "\\" + folder).listFiles(new FilenameFilter()
			{
				public boolean accept(File dir, String name)
				{
					if (!name.toUpperCase().contains("README"))
						return name.endsWith(fileType);
					else
						return false;
				}
			});
			
//			OutFile out = null;
//			try
//			{
//				out = new OutFile(path + "\\" + folder + ".txt", false);
//			}
//			catch (IOException e)
//			{
//				System.err.println("Error in setting up output file " + path + ".txt");
//				e.printStackTrace();
//			}
			
			for (File inputFile : inputFiles)
			{
				log.writeLine(inputFile.getName().replace(fileType, ""));
				HashMap<Integer, CandidateData> data = new HashMap<Integer, CandidateData>();
				
				InFile in = null;
				try
				{
					in = new InFile(inputFile);
				}
				catch (IOException e)
				{
					log.writeLine("Error in opening " + inputFile.getAbsolutePath());
					e.printStackTrace();
				}
				
				String[] line, offices, districts;
				ArrayList<String[]> topLines = new ArrayList<String[]>();
				try
				{
					//line = in.readRowLite("\t");			
//					while (!line.toLowerCase()
//							.matches("^[^\t]+(\t+[^\t]+){3,7}(\t((([\\d]+)|((unopposed){1}))[\\s]?)?)*$")) //looks good, other than some 1996 
					boolean lineIsHeader = true;
					while (lineIsHeader && in.isReady())
					{
						line = in.readRowLite( "\t"); //at the end of the loop, will have the first data line
						int numericCols = 0;
						for (String cell : line)
						{
							cell = cell.replaceAll(",", "")
									.replaceAll("\"", "")
									.replaceAll("unopposed", "1").trim();
							if (cell.matches("^[\\d\\.]+$"))
								numericCols++;
						}
						
						if (numericCols >= 5)
							lineIsHeader = false;
						else
							topLines.add(line);
					}
					
					if (in.isReady())
					{
						offices = topLines.get(0);
						districts = new String[offices.length];
						
						for (int col = 0; col < offices.length; col++)
						{
							for (int topLine = 1; topLine < topLines.size()-1; topLine ++)
								offices[col] += " " + topLines.get(topLine)[col].trim();
							
							districts[col] = "";
							String officeCheck = offices[col].toUpperCase();
							if (officeCheck.contains("DISTRICT") && !officeCheck.contains("ATTORNEY"))
								districts[col] = officeCheck
										.substring(officeCheck.lastIndexOf("DISTRICT"))
										.replaceAll("\\D", "").trim();
							else if (offices[col].toUpperCase().contains("PLACE"))
								districts[col] = offices[col]
										.substring(officeCheck.lastIndexOf("PLACE")).trim();
								
							offices[col] = ElectionData.checkStatic(offices[col]);
						}
						
						log.writeLine(Arrays.toString(offices) + "\r\n"
								+ Arrays.toString(districts) + "\r\n"
								+ Arrays.toString(topLines.get(topLines.size()-1))); //TODO deal with office names not being associated with 2+ districts
						//continue with data processing, first data row stored in current value of line
					}
					else
						log.writeLine("<<Blank File>>");
				}
				catch(IOException e)
				{
					log.writeLine("Error in reading rows of " + inputFile.getAbsolutePath());
					e.printStackTrace();
				}
				catch (Exception e)
				{
					log.writeLine("Unchecked exception thrown while reading " + inputFile.getAbsolutePath());
					e.printStackTrace();
				}
				log.writeLine("*****************");
//					int rowStart = 0;
//					int rowEnd = sheet.getRows();
//					int nullRowsChecked = 0;
//					final int MAX_NULL_ROW_CHECK = 20;
//					final int MY_MINIMUM_COLUMN_COUNT = 5;
//					System.out.println("Input file: " + inputFile.getPath()
//							+ "- number of rows = " + rowEnd);
//						----------
//						Row offices = sheet.getRow(rowStart);
//						rowStart++;
//						Row candidates = sheet.getRow(rowStart);
//						rowStart++;
//						
//						int lastColumn = Math.max(candidates.getLastCellNum()+1, MY_MINIMUM_COLUMN_COUNT);
//						String previousNonNull = "Precinct";
//						String offCode = "";
//						String district = "";
//						
//						//Header info rows
//						for (int cn = 0; cn < lastColumn; cn++)
//						{
//							Cell office = offices.getCell(cn, Row.RETURN_BLANK_AS_NULL);
//							Cell cand = candidates.getCell(cn, Row.RETURN_BLANK_AS_NULL);
//							
//							if (office != null)
//							{
//								previousNonNull = office.toString();
//								String check = ElectionData.checkStatic(previousNonNull);
//								if (!check.equals(""))
//									offCode = check;
//								else
//									offCode = previousNonNull;
//								
//								if (previousNonNull.toUpperCase().contains(" DIST. "))
//								{
//									district = previousNonNull.toUpperCase()
//											.substring(previousNonNull.lastIndexOf(".")+1).trim();
//									if (offCode.equals(previousNonNull))
//										offCode = offCode.substring(0, offCode.toUpperCase().indexOf(" DIST. "))
//												.replaceAll(",", "").trim();
//								}
//								else if (previousNonNull.contains(" Pl "))
//								{
//									district = previousNonNull.substring(previousNonNull.lastIndexOf("Pl"));
//									if (offCode.equals(previousNonNull))
//										offCode = offCode.substring(0, offCode.lastIndexOf("Pl")).trim();
//								}
//								else
//									district = "";
//							}
//							
//							if(cand != null)
//							{
//								data.put(cn, new CandidateData(state, type, cand.toString(), party, year));
//								data.get(cn).setOffice(offCode);
//								data.get(cn).setDistrict(district);
//							}
//						} //end header rows loop
//						
//						Row r;
//						for (int rowNum = rowStart; rowNum < rowEnd; rowNum++)
//						{
//							r = sheet.getRow(rowNum);
//							if (r == null)
//							{
//								nullRowsChecked++;
//								if (nullRowsChecked >= MAX_NULL_ROW_CHECK)
//									break;
//								else
//									continue;
//							}
//							
//							int col = 0;
//							Cell c = r.getCell(col, Row.RETURN_BLANK_AS_NULL);
//							col++;
//							String location = c.toString();
//							if (location.contains("Calculated"))
//								continue;
//							
//							for (int cn = col; cn < lastColumn; cn++)
//							{
//								c = r.getCell(cn, Row.RETURN_BLANK_AS_NULL);
//								if (c != null)
//									data.get(cn).addData(new ElectionData(location,
//											Integer.parseInt(c.toString().replace(".0", "")), -1.0));
//							} //end cells loop
//						} //end row loop
//						
//						for (CandidateData cand : data.values())
//						{
//							try
//							{
//								out.write(cand.getRows("\t"));
//							}
//							catch (IOException e)
//							{
//								System.err.println("Error in writing to file; data: " + cand.getRows());
//								e.printStackTrace();
//							}
//						} //end write loop
					} //end sheets iterator loop
//				} //end workbook try
//				catch (IOException e) 
//				{
//					e.printStackTrace();
//				}
//				finally
//				{
//					try
//					{
//						workbook.close();
//						out.close();
//					}
//					catch (IOException e)
//					{
//						System.err.println("Error in processing " + inputFile.getAbsolutePath());
//						e.printStackTrace();
//					}
//				} //finally for workbook try
//			} //end files in folders loop
		} //end folders loop
	} //end main
}
