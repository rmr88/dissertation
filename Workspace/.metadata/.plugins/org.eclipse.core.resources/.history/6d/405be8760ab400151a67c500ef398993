package tasks;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import utilities.CandidateData;
import utilities.Columns;
import utilities.ElectionData;
import utilities.InFile;
import utilities.OutFile;
import utilities.State;

public class ElectionParser
{
	private State state;
	private OutFile out = null;
	
	private String[] pOff = {"AL", "ID"};
	private String[] pLoc = {};
	private String[] pCL = {"FL", "IL"};
	
	private List<String> parseByOffice = Arrays.asList(pOff);
	private List<String> parseByLocation = Arrays.asList(pLoc);
	private List<String> parseByCandLoc = Arrays.asList(pCL);
	
	public ElectionParser(State _state)
	{
		this.state = _state;
	}
	
	public void run() //TODO want to return anything for ScrapeAndParse to post-process?
	{
		System.out.println(this.state.getState() + ": parse");
		this.initializeOut(this.state.getPath() + "\\" + this.state.getState()
				+ "_" + this.state.getGeoType() + ".txt");

		for (int year : this.state.getYears())
		{
			System.out.print("\t" + year);
			File file = new File(this.state.getPath() + "\\" + year + "_"
					+ this.state.getGeoType() + this.state.getFileType());

			if (file.exists())
			{ //if years are in files:
				if (this.parseByCandLoc.contains(this.state.getState()))
				{
					System.out.println(": Parsing by candidate/ location");
					this.candLocation(year, file);
				}
				else if (this.parseByOffice.contains(this.state.getState()))
				{
					System.out.println(": Parsing by offices");
					this.offices(year, file, new ArrayList<CandidateData>());
				}
			} 
			else
			{ //if years are in folders:
				file = new File(this.state.getPath() + "\\" + year + "_" + this.state.getGeoType());
				if (file.isDirectory())
				{
					if (state.getOffices().length != 0)
					{
						System.out.println(": Parsing by offices");
						this.offices(year, file, new ArrayList<CandidateData>());
					}
					else if (state.getLocations().length != 0)
						this.location(year);
					else
					{
						File[] inputFiles = this.getFileList(this.state.getPath() + "\\"
								+ year + "_" + this.state.getGeoType());
						int officesFound = 0;
						for (File inputFile : inputFiles)
						{
							String name = inputFile.getName().toUpperCase();
							if (name.contains("USH_") || name.contains("USP_") ||
									name.contains("USS_") || name.contains("GOV_"))
								officesFound++;
						}
						
						if (officesFound < 2)
						{
							ArrayList<CandidateData> parties = this.getParties();
							System.out.println(": Parsing by offices");
							for (File inputFile : inputFiles)
								this.offices(year, inputFile, parties);
						}
						else
							System.err.println("uncoded case");
//							this.candLocation(year); //TODO still not sure how this ends up...
					}
				}
				else //warning if no valid file, directory found
					System.err.println("No data file found for year " + year + ".");
			}
		} //end years for loop
		out.close();
	} //end run method
	
	public void offices(int year, File file, ArrayList<CandidateData> parties)
	{
		try
		{
			out.writeLine("state\tyear\tgeographyType\tname\toffice\t"
					+ "district\tparty\tlocationName\tvotes\tvotePerc");
		}
		catch (IOException e1)
		{
			System.err.println("Error writing header line for " + this.state.getState() + ", " + year);
			e1.printStackTrace();
		}
		HashMap<Integer, CandidateData> data = new HashMap<Integer, CandidateData>();
		
		//to determine AL counties:
		String county = file.getName().toUpperCase()
				.replaceAll("_SHEET[\\d]?", "").replace(this.state.getFileType().toUpperCase(), "")
				.replace(".", "").replaceAll("1996_COMPILED_RESULTS_", "");
		if (county.contains("_"))
			county = county.substring(county.lastIndexOf("_")+1);
		String location = county;
		
		InFile in = null;
		in = this.initializeIn(file);
		
		String[] line = null;
		String[] offices, districts, names;
		String[] partyArr = null;
		ArrayList<String[]> topLines = new ArrayList<String[]>();
		
		try //try to process files
		{ 
			boolean lineIsHeader = true;
			while (lineIsHeader && in.isReady()) //collect all header data into a single object
			{
				line = in.readRowLite("\t"); //at the end of the loop, will have the first data line
				int numericCols = 0;
				int partiesFound = 0;
				for (String cell : line)
				{
					cell = cell.replaceAll(",", "")
							.replaceAll("\"", "")
							.replaceAll("unopposed", "1").trim();
					if (cell.matches("^[\\d\\.]+$"))
						numericCols++;
					else if (cell.toUpperCase().equals("DEM") || cell.toUpperCase().equals("DEM.")
							|| cell.toUpperCase().equals("REP") || cell.toUpperCase().equals("REP.")
							|| cell.toUpperCase().equals("IND") || cell.toUpperCase().equals("IND."))
						partiesFound++;
				}
				
				if (numericCols >= 5)
					lineIsHeader = false;
				else if (partiesFound >= 9)
					partyArr = line;
				else
					topLines.add(line);
			} //end header collection loop
			
			if (in.isReady()) //process a file with data
			{
				boolean haveNames = false;
				while (!haveNames && topLines.size() >= 2)
				{ //checking for office code row below names (AL)
					int officesFound = 0;
					int allCapsCells = 0;
					int emptyCells = 0;
					for (String col : topLines.get(topLines.size()-1))
					{
						if (!ElectionData.checkStatic(col).equals(""))
							officesFound++;
						if (col.matches("^[^a-z]+"))
							allCapsCells++;
						if (col.equals(""))
							emptyCells++;
					}

					if (emptyCells >= topLines.get(topLines.size()-1).length-1
							&& !topLines.get(topLines.size()-1)[0].equals(""))
						location = topLines.get(topLines.size()-1)[0];
					if ((officesFound >= 2 && allCapsCells >= 10)
							|| emptyCells >= topLines.get(topLines.size()-1).length-1)
						topLines.remove(topLines.size()-1);
					else
						haveNames = true;
				} //end check for office code row
				
				offices = topLines.get(0);
				districts = new String[offices.length];
				names = topLines.get(topLines.size()-1);
				//topLines.remove(topLines.size()-1);
				
				boolean matchMade = false;
				int firstOfficeCol = 0;
				for (int col = 0; col < offices.length; col++)
				{ //process header data
					for (int row = 1; row < topLines.size()-1; row ++)
						offices[col] += " " + topLines.get(row)[col].trim();
					
					districts[col] = "";
					String officeCheck = offices[col].toUpperCase().trim();
					if ((officeCheck.contains("DISTRICT") && !officeCheck.contains("ATTORNEY"))
							|| officeCheck.contains("CIRCUIT"))
						districts[col] = officeCheck.replaceAll("\\D", "").trim();
					else if (officeCheck.toUpperCase().contains("PLACE"))
						districts[col] = officeCheck
								.substring(officeCheck.lastIndexOf("PLACE")).trim();
					
					if (offices[col].toUpperCase().trim().equals(districts[col]))
						offices[col] = "";
					
					officeCheck = ElectionData.checkStatic(officeCheck);
					if (!officeCheck.equals(""))
					{
						offices[col] = officeCheck;
						if (!matchMade)
						{
							firstOfficeCol = col;
							matchMade = true;
						}
					}
					else if (!matchMade)
						offices[col] = "";
				} //end process header data
				
				String office = "";
				String district = "";
				for (int col = firstOfficeCol; col < offices.length; col++)
				{ //create CandidateData objects, put in data map
					if (!offices[col].equals(""))
					{
						office = offices[col].trim();
						district = "";
					}
					if (!districts[col].equals(""))
						district = districts[col].trim();
					
					int ptyIndex = 0;
					boolean ptyMatched = false;
					String party = "";
					if (parties.size() == 0 && partyArr != null)
						party = partyArr[col].replace(".", "");
					else if (parties.size() > 0)
					{
						while (!ptyMatched && ptyIndex < parties.size())
						{
							party = parties.get(ptyIndex).partyCheck(names[col], year, office, district);
							if (!party.equals(""))
								ptyMatched = true;
							ptyIndex++;
						}
					}
					else
						System.err.println("No party data identified in " + file.getPath());
					
					if (!names[col].equals(""))
					{
						data.put(col, new CandidateData(this.state.getState(),
								this.state.getGeoType(), names[col], party, year));
						data.get(col).setOffice(office);
						data.get(col).setDistrict(district);
					}
				} //end create CandidateData objects
				
				while (in.isReady()) //loop through data lines, create ElectionData objects
				{
					int blankCols = 0;
					for (String col : line)
						if (col.equals(""))
							blankCols++;
					
					if (blankCols == line.length-1 && !line[0].equals(""))
					{
						location = line[0]; //TODO debug this
						System.out.println(location);
					}
					else if (blankCols < line.length)
					{
						if (location.contains("_"))
							location = location.substring(0, location.indexOf("_"));
						
						for (int col = 0; col < firstOfficeCol; col++)
							location += "_" + line[col];
						
						for (int col = firstOfficeCol; col < offices.length; col++)
						{
							if (line[col].toUpperCase().trim().equals("UNOPPOSED"))
								data.get(col).addData(new ElectionData(location, 0, 100.0));
							else if (!line[col].trim().replaceAll("\\D", "").equals("")
									&& data.containsKey(col))
							{
								data.get(col).addData(new ElectionData(location,
										Integer.parseInt(line[col]
												.replaceAll("\\D", "")
												.trim()), -1.0));
							}
						}
					}
					line = in.readRowLite("\t");
				} //end loop through data lines
				
				for (Integer key : data.keySet())
					out.write(data.get(key).getRows("\t"));
			} //end process file with data
			else
				out.write("<<Blank File>>");
		}
		catch(IOException e)
		{
			System.err.println("Error in reading rows of " + file.getAbsolutePath());
			e.printStackTrace();
		} //end try to process files
	} //end offices method
	
	public void candLocation(int year, File file)
	{
		System.out.println(": Parsing by location");
		InFile in = null;
		in = this.initializeIn(file);
		
		String headerStr = null;
		try
		{
			headerStr = in.readLine();
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
		String delim = InFile.determineDelimiter(headerStr);
		String[] header = headerStr.split(delim);
		
		ArrayList<Integer> locationInds  = new ArrayList<Integer>(),
				officeInds = new ArrayList<Integer>(),
				distInds = new ArrayList<Integer>(),
				partyInds = new ArrayList<Integer>(),
				nameInds = new ArrayList<Integer>(),
				voteInds = new ArrayList<Integer>();
		
		//Get lists of possible columns for the five fields
		for (int index = 0; index < header.length; index++)
		{
			String check = header[index].toLowerCase();
			if (Columns.LOCATION.check(check))
				locationInds.add(index);
			else if (Columns.OFFICE.check(check))
				officeInds.add(index);
			else if (Columns.PARTY.check(check))
				partyInds.add(index);
			else if (Columns.VOTE.check(check))
				voteInds.add(index);
			else if (Columns.CANDNAME.check(check))
				nameInds.add(index);
			else if (Columns.DIST.check(check))
				distInds.add(index);
		}

		int locationInd = -1,
				partyInd = -1,
				nameInd = -1,
				voteInd = -1,
				officeInd = -1,
				distInd = -1;
		
		//Get unique column indices for the five fields.
		if (locationInds.size() == 1 && header[locationInds.get(0)].toLowerCase().equals(this.state.getGeoType()))
			locationInd = locationInds.get(0);
		else
		{
			try { locationInd = this.getUniqueCol(locationInds, header, Columns.LOCATION); }
			catch (Exception e)
			{
				System.err.println("Error: unique location name column not identified for "
						+ this.state.getState() + ", " + year);
				e.printStackTrace();
			}
		}
		
		try { voteInd = this.getUniqueCol(voteInds, header, Columns.VOTE); }
		catch (Exception e)
		{
			System.err.println("Error: unique vote column not identified for "
					+ this.state.getState() + ", " + year);
			e.printStackTrace();
		}
		
		try { partyInd = this.getUniqueCol(partyInds, header, Columns.PARTY); }
		catch (Exception e)
		{
			System.err.println("Error: unique party abbreviaton column not identified for "
					+ this.state.getState() + ", " + year);
			e.printStackTrace();
		}
		
		try { nameInd = this.getUniqueCol(nameInds, header, Columns.CANDNAME); }
		catch (Exception e)
		{
			System.err.println("Error: unique candidate name column not identified for "
					+ this.state.getState() + ", " + year);
			e.printStackTrace();
		}
		
		try { officeInd = this.getUniqueCol(officeInds, header, Columns.OFFICE); }
		catch (Exception e)
		{
			System.err.println("Error: unique candidate name column not identified for "
					+ this.state.getState() + ", " + year);
			e.printStackTrace();
		}
		
		try { distInd = this.getUniqueCol(distInds, header, Columns.DIST); }
		catch (Exception e) {} //could log the fact that district is embedded in office column
		
		String[] line;
		Pattern distPattern = Pattern.compile("([\\D]*[\\d]+[\\D]*\\s).*");
		try
		{
			while (in.isReady())
			{
				line = in.readRowLite(delim);
				
				String office = line[officeInd].replaceAll("\"", "").toUpperCase();
				String dist = "";
				if (distInd >= 0)
				{
					dist = line[distInd];
				}
				else
				{
					Matcher distMatcher = distPattern.matcher(office);
					
					if (distMatcher.matches())
					{
						dist = distMatcher.group(1).replaceAll("\\D", "").trim();
						office = office.replace(distMatcher.group(1), "").trim();
					}
					
					if (office.contains("CIRCUIT"))
						dist = office;
				}
				
				if (office.toUpperCase().equals("GOVERNOR AND LIEUTENANT GOVERNOR"))
					office = "GOV";
				else
				{
					String key = ElectionData.checkStatic(office);
					if (!key.equals(""))
						office = key;
					
					if (key.equals("USS") && !dist.equals(""))
						office = "STS"; //accounting for IL state senate designations
				}
				
				out.writeLine(this.state.getState() + "\t" + year + "\t"
						+ this.state.getGeoType() + "\t"
						+ line[locationInd].replaceAll("\"", "") + "\t"
						+ office + "\t" + dist + "\t"
						+ line[nameInd].replaceAll("\"", "") + "\t"
						+ line[partyInd].replaceAll("\"", "") + "\t"
						+ line[voteInd].replaceAll("\"", "") + "\t-1.0");
			}
		}
		catch (IOException e)
		{
			System.err.println("Error in reading data line for "
					+ this.state.getState() + ", " + year);
		}
	} //end locations method
	
	public void location(int year)
	{
		
	} //end location method
	
	public ArrayList<CandidateData> getParties()
	{
		InFile partyFile = null;
		ArrayList<CandidateData> parties = new ArrayList<CandidateData>();
		try
		{
			partyFile = new InFile(this.state.getPath() + "\\parties.txt");
			partyFile.readLine();
			while (partyFile.isReady())
			{
				String[] ptyLine = partyFile.readRowLite("\t");
				parties.add(new CandidateData(Integer.parseInt(ptyLine[0]),
						ptyLine[1], ptyLine[2].split(" "), ptyLine[3], ptyLine[4]));
			}
			partyFile.close();
		}
		catch (FileNotFoundException e) {}
		catch (IOException e)
		{
			System.err.println("Error in reaidng party data.");
			e.printStackTrace();
		}

		return parties;
	} //end getParties method
	
	public File[] getFileList(String path)
	{
		File[] inputFiles = new File(path).listFiles(new FilenameFilter()
		{
			public boolean accept(File dir, String name)
			{
				if (!name.toUpperCase().contains("SUMMARY")
						&& !name.toUpperCase().contains("README"))
					return name.endsWith(state.getFileType());
				else
					return false;
			}
		});
		return inputFiles;
	} //end getFileList method
	
	public void initializeOut(String path)
	{
		try
		{
			this.out = new OutFile(path, false);
		}
		catch (IOException e)
		{
			System.err.println("Error in setting up output file " + path);
			e.printStackTrace();
		}
	}
	
	public InFile initializeIn(String path)
	{
		try
		{
			return new InFile(path);
		}
		catch (IOException e)
		{
			System.err.println("Error in opening " + path);
			e.printStackTrace();
			return null;
		}
	}
	
	public InFile initializeIn(File file)
	{
		try
		{
			return new InFile(file);
		}
		catch (IOException e)
		{
			System.err.println("Error in opening " + file.getAbsolutePath());
			e.printStackTrace();
			return null;
		}
	}

	public int getUniqueColNoCheck(ArrayList<Integer> cols) throws Exception
	{
		int col = 0;
		
		if (cols.size() > 1)
			throw new Exception(); //TODO could write a specific exception for this
		else if (cols.size() == 1)
			col = cols.get(0);
		else
			throw new Exception();
		
		return col;
	}
	
	public int getUniqueCol (ArrayList<Integer> cols, String[] colText, Columns colElement)
			throws Exception
	{
		int col = 0;
		
		if (cols.size() > 1)
		{
			for (int index = 0; index < cols.size(); index++)
			{
				if (colElement.check2(colText[cols.get(index)].toLowerCase()))
					col += cols.get(index);
			}
		}
		else
			col = cols.get(0);
					
		if (col >= 0 && col < colText.length)
			return col;
		else
			throw new Exception();
	}
}
